# net library
Документация в данный момент только на русском, так как библиотека находится в альфа разработке.
Примечание: Это не полная копия реального стека, здесь нет например CRC для проверки целосности пакетов, т.к. мод не нарушает содержимое пакетов(в данный момент), тоже самое и с флагами начала и конца слоя, здесь будет использоватся сериализация т.к. десеарилизация нативная и, следовательно, быстрая.

Всё взаимодействие происходит на порте `1`.

Термины:
- layer - слой [TCP/IP](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%82%D0%B5%D0%B2%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_OSI) стека, хотя эталонным и считается [OSI](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%82%D0%B5%D0%B2%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_OSI) стек, в реальности он соблюдается формально. Каждый стек в проэкте обозначается соим именем:
- drivers(OSI - L1) - физический уровень, предоставлен в моде "из коробки" в библиотеке реализованны "оболочки" для удобства. устройства - связанная карта, сетевая карта, беспроводная карта...(в теории возможно добавление своих устройств(полным эмулированием апи модема), но такие вещи как, например, корекцию ошибок реализуйте сами).
- LinkLayer(OSI - L2) - прослойка между драйверами и субмодулями(протоколами), имеет проверки на адрес отправи, адрес приема, существование протокола и наличие данных.
    - asvNetEthernet - Субмодуль, в библиотеке повторяет функции `send, broadcast` модуля `LinkLayer` за исключением что он вставляет свое имя в протокол, используется как транспорт для INet.

## подключение в коде:
`local net = require("asv").net`

## drivers
Уровень отвечающий за передачу данных, а также работу модема. Используется для прямой связи между устройствами.
Также универсализирует API к тунелям и модемам, далее эти 2 устройства в тексте упоминаются как модем.

Путь к модулю: `net.phys`

### `getModemFromAddress(addr, dontTakeByDefault): modem`
Найти модем по адресу или вернуть модем по умолчанию.\
Параметры:
* `addr:string, nil`
  * `nil` - возвращает `"primary"` модем
  * `string` - найти модем по адресу, полному или частичному, вызывается cmp.get с соответствующими ошибками
* `dontTakeByDefault: nil, boolean` - (может быть убран) если `addr` не задан и этот параметр `false` ищет modem или tunnel компонентов.
Возвращает:
* `modem` - ванильный пропатченный обьект модема. Добовляется таблица `asvnet`:
  * `send(dstAddr, ...)` - вызывает ванильный send модема(`send(dstAddr, port, ...)`) но вставляет 2 параметром дефолтный порт, тунелям передается только `...`
  * `broadcast(...)` - вызывает ванильный broadcast модема(`broadcast(port, ...)`) но вставляет 1 параметром дефолтный порт, тунелям передается только `...`

### `broadcastViaAll(...): success, reasons`
Отправка сообщения через все доступные адаптеры. (порт - по умолчанию)\
Параметры:
* `...` - данные для отправки.
Возвращает:
* `success:boolean` - удалось ли отправить
* `reason:nil, table` - если `success = false` то вернет таблицу строк формата `{["адрес карты - источника"]="причина", ..., n=(число ошибок)}` с причиной как из ванильного модема

### `broadcast(srcAddr, ...): success, reason`
Отправка сообщения через указанный сетевой адаптер всем клиентам. (порт - по умолчанию)\
Параметры:
* `srcAddr:string, nil` - Полный или частичный адрес адаптера. Если передан `nil` будет взято primary устройство.\
* `...` - данные для отправки.
Возвращает:
* `success:boolean` - удалось ли отправить
* `reason:nil, string` - если `success = false` то вернет строку с причиной как из ванильного модема

### `send(srcAddr, dstAddr, ...): success, reason`
Отправка сообщения через указанный сетевой адаптер на указанный узел. (порт - по умолчанию)\
Параметры:
* `srcAddr:string, nil` - Полный или частичный адрес адаптера. Если передан `nil` будет взято primary устройство.\
* `dstAddr:string` - Полный адрес принимающей стороны.\
* `...` - данные для отправки.
Возвращает:
* `success:boolean` - удалось ли отправить
* `reason:nil, string` - если `success = false` то вернет строку с причиной как из ванильного модема

## LinkLayer
Модуль является прослойкой между drivers и протоколами этого уровня, подготавливает данные(сериализирует) для передачи/приема через сеть.

Путь к модулю: `net.Layers.Link`

### `broadcast(srcAddr, protocol, data): success, reason(s)`
Отправка сообщения через указанный сетевой адаптер всем клиентам. (порт - по умолчанию)\
Параметры:
* `srcAddr:string, nil` - Полный или частичный адрес адаптера. Если передан `nil` данные отправятся через все интерфейсы, если передан "primary" будет взято primary устройство.\
* `protocol:string` - имя протокола(этого уровня),
* `data:boolean, number, string, table` - данные для отправки.
Возвращает:
* результат/ошибки из `broadcast` или `broadcastViaAll` модуля drivers

### `send(srcAddr, dstAddr, protocol, data): success, reason`
Отправка сообщения через указанный сетевой адаптер на указанный узел. (порт - по умолчанию)\
Параметры:
* `srcAddr:string, nil` - Полный или частичный адрес адаптера. Если передан `nil` будет взято primary устройство.\
* `dstAddr:string` - Полный адрес принимающей стороны.\
* `protocol:string` - имя протокола(этого уровня),
* `data:boolean, number, string, table` - данные для отправки.
Возвращает:
* результат/ошибки из `send` модуля drivers

#### Прием данных
После приема сообщения оно проверяется по следующим пунктам:
- Номер порта должен быть `1`(по умолчанию, определяется net.phys.service.port). 
- Тип поля данных должен быть `string`, для десериализации.
- "фрейм" должен содержать 2 поля, `protocol` и `data`, при нехватке - обработка прервется, лишние поля удалятся.
После всех проверок вызывается функция `onMessageReceived` в конечном протоколе. В функцию передается:
* `dstAddr:string` - Адрес адаптера принявшего сообщение.
* `data:string` - Десериализованная таблица с данными. Со структурой `frameItem`.
* `srcAddr:string` - Адрес адаптера отправившего сообщение.
* `port:number` - Порт через который было принято сообщение.
* `distance:number` - При беспроводной передаче - расстояние до истоника данных. При проводной - `0`.

#### Добавление своего протокола
L2 протокол добавляется следующим образом:
```lua
net.Layers.Link.protocols[protoName] = {
    onMessageReceived = function(dstAddr, frame, srcAddr)   --функция вызываемая при приеме пакета для этого протокола. опционально.
        --do someting
    end,
    postInitialization = function(newnet, name)   --функция вызываемая при первой инициализации всей библиотеки net, в данный момент больше никогда не вызывается. опционально.
        net.Layers.Link.protocols[name].postInitialization = nil   --опционально
        --do someting
    end
}
```
* `protoName: string` - имя вашего протокола, уникальное в еденицу времени

#### Удаление своего протокола
`net.Layers.Link.protocols[protoName] = nil`

#### `asvNetEthernet`
модуль-обертка для L3 Internet модуля.
Путь к модулю: `net.Layers.Link.protocols.asvNetEthernet`

##### `broadcast(srcAddr, data)`
##### `send(srcAddr, dstAddr, data)`
##### `onMessageReceived(dstAddr, data, srcAddr)`

## `arp`
L2 запрос "адреса" или любой другой информации. Помимо прямого назначения - запрашивать физический адрес для протоколов уровнем выше, можно использовать как внутрисетевой DNS.
Путь к модулю: `net.Layers.Link.protocols.arp`

##### `add(address, protocol, devAddr, timeout, data, canBeUsedToAnswer)`
Добавить адрес(перезаписать) в таблицу кэша.
* `address:string, number` - адрес который предполагается искать.
* `protocol:string` - протокол для которого следует делать поиск.
* `devAddr:string, nil` - Полный или частичный адрес адаптера. Если передан `nil` данные отправятся через все интерфейсы.
* `timeout:number, nil` - время, после которого запись удаляется, 0 - не удаляется, nil - время по умолчанию, UNIX формат.
* `data:nil, boolean, number, string, table` - данные.
* `canBeUsedToAnswer:boolean, nil` - разрешить использовать этот адрес для ответа.

##### `remove(address, protocol, keepProtocolTable)`
Удалить адрес из таблицы кэша.
* `address:string, number` - адрес который предполагается искать.
* `protocol:string` - протокол для которого следует делать поиск.
* `keepProtocolTable:boolean, nil` - (для внутреннего использования, оставлять в nil или false) Не удалять таблицу протокола если она пуста.

##### `get(address, protocol, devAddr, forResponsible): success, data`
Получить адрес из таблицы кеша или запросить его из сети.
Параметры:
* `address:string, number` - адрес который предполагается искать.
* `protocol:string` - протокол для которого следует делать поиск.
* `devAddr:string, nil` - Полный или частичный адрес адаптера. Если передан `nil` данные отправятся через все интерфейсы.
* `forResponsible:boolean, nil` - (для внутреннего использования, оставлять в nil или false) Искать только в кеше и только с пометкой canBeUsedToAnswer.
Возвращает:
* `success:boolean` - удалось ли получить данные
* `data:nil, boolean, number, string, table` - данные.

##### `onMessageReceived(dstAddr, data, srcAddr)`
* `dstAddr: string` - Адрес адаптера принявшего сообщение.
* `data: string` - Tаблица с данными. Со структурой `frameItem`.
* `srcAddr: string` - Адрес адаптера отправившего сообщение.
